// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// To switch back to PostgreSQL (e.g., for production on NeonDB):
// 1. Change the provider below back to "postgresql".
// 2. Ensure your DATABASE_URL in the .env file points to your NeonDB connection string.
datasource db {
  provider = "sqlite" // Changed from "postgresql" for local development
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// ===================================
// MODELS
// ===================================

model User {
  id                 String   @id @default(cuid())
  name               String
  email              String   @unique
  avatarUrl          String?
  subscriptionStatus String   @default("trial") // active, inactive, trial
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  ownedVaults     Vault[]          @relation("VaultOwner")
  vaults          VaultMember[]
  accounts        Account[]
  transactions    Transaction[]    @relation("UserTransactions") // Named relation
  actedOn         Transaction[]    @relation("ActorTransactions") // Named relation
  goals           Goal[]
  goalParticipants GoalParticipant[]
  notifications   Notification[]
  invitationsSent Invitation[]     @relation("SentInvitations")
  invitationsRcvd Invitation[]     @relation("ReceivedInvitations")
}

model Vault {
  id        String   @id @default(cuid())
  name      String
  imageUrl  String?
  ownerId   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  owner       User             @relation("VaultOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  members     VaultMember[]
  accounts    Account[]
  transactions Transaction[]
  goals       Goal[]
  
  @@index([ownerId])
}

model VaultMember {
  id        String   @id @default(cuid())
  userId    String
  vaultId   String
  role      String   @default("member") // owner, admin, member
  createdAt DateTime @default(now())

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  vault Vault @relation(fields: [vaultId], references: [id], onDelete: Cascade)

  @@unique([userId, vaultId])
  @@index([userId])
  @@index([vaultId])
}

model Account {
  id              String   @id @default(cuid())
  name            String
  bank            String
  type            String // checking, savings, investment, credit_card, other
  balance         Float
  creditLimit     Float?
  logoUrl         String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // Relacionamento com o dono
  ownerId         String
  owner           User     @relation(fields: [ownerId], references: [id], onDelete: Cascade)

  // Relacionamento opcional com um cofre (se for conta conjunta)
  vaultId         String?
  vault           Vault?   @relation(fields: [vaultId], references: [id], onDelete: SetNull)

  // Campos para controle de visibilidade
  scope           String   // 'personal' ou 'vaultId' se for conjunta
  visibleIn       String?  // Armazena uma string de vaultIds separados por vírgula

  sourceTransactions      Transaction[] @relation("TransactionSource")
  destinationTransactions Transaction[] @relation("TransactionDestination")
  
  @@index([ownerId])
  @@index([vaultId])
}

model Transaction {
  id                  String    @id @default(cuid())
  ownerType           String // 'user' or 'vault'
  date                DateTime
  description         String
  amount              Float
  type                String // income, expense, transfer
  category            String
  paymentMethod       String?
  isRecurring         Boolean   @default(false)
  isInstallment       Boolean   @default(false)
  installmentNumber   Int?
  totalInstallments   Int?
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  // Dono da transação (pode ser um usuário ou um cofre)
  ownerId             String
  userId              String?
  user                User?     @relation("UserTransactions", fields: [userId], references: [id], onDelete: SetNull)
  vaultId             String?
  vault               Vault?    @relation(fields: [vaultId], references: [id], onDelete: SetNull)
  
  // Quem realizou a ação
  actorId             String
  actor               User      @relation("ActorTransactions", fields: [actorId], references: [id], onDelete: Cascade)
  
  // Contas de origem e destino
  sourceAccountId      String?
  sourceAccount        Account?  @relation("TransactionSource", fields: [sourceAccountId], references: [id], onDelete: SetNull)
  destinationAccountId String?
  destinationAccount   Account?  @relation("TransactionDestination", fields: [destinationAccountId], references: [id], onDelete: SetNull)
  
  // Relacionamento com meta (opcional)
  goalId              String?
  goal                Goal?     @relation(fields: [goalId], references: [id], onDelete: SetNull)

  @@index([ownerId])
  @@index([userId])
  @@index([vaultId])
  @@index([actorId])
  @@index([sourceAccountId])
  @@index([destinationAccountId])
  @@index([goalId])
}

model Goal {
  id             String   @id @default(cuid())
  name           String
  targetAmount   Float
  currentAmount  Float    @default(0)
  emoji          String
  visibility     String   @default("shared") // private, shared
  isFeatured     Boolean  @default(false)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  
  // Dono da meta
  ownerId        String
  ownerType      String // 'user' or 'vault'
  userId         String?
  user           User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  vaultId        String?
  vault          Vault?   @relation(fields: [vaultId], references: [id], onDelete: SetNull)
  
  participants   GoalParticipant[]
  transactions   Transaction[]
  
  @@index([ownerId])
  @@index([userId])
  @@index([vaultId])
}

model GoalParticipant {
  id                    String   @id @default(cuid())
  role                  String   @default("member")
  contributionContextId String?  // User or Vault ID for contributions
  createdAt             DateTime @default(now())

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  goalId String
  goal   Goal   @relation(fields: [goalId], references: [id], onDelete: Cascade)

  @@unique([userId, goalId])
  @@index([userId])
  @@index([goalId])
}


model Notification {
  id           String   @id @default(cuid())
  type         String // goal_invite, vault_invite, transaction_added, etc.
  text         String
  read         Boolean  @default(false)
  link         String?
  relatedId    String?
  createdAt    DateTime @default(now())

  userId       String
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  actorId      String?
  actorName    String?
  actorAvatar  String?

  @@index([userId])
}

model Invitation {
  id          String   @id @default(cuid())
  type        String // vault, goal
  targetId    String // vaultId ou goalId
  targetName  String
  status      String   @default("pending") // pending, accepted, declined
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  senderId    String
  sender      User     @relation("SentInvitations", fields: [senderId], references: [id], onDelete: Cascade)
  
  receiverId  String
  receiver    User     @relation("ReceivedInvitations", fields: [receiverId], references: [id], onDelete: Cascade)
  
  @@index([senderId])
  @@index([receiverId])
}


model SavedReport {
  id           String   @id @default(cuid())
  ownerId      String
  monthYear    String
  analysisHtml String
  createdAt    DateTime @default(now())

  @@unique([ownerId, monthYear])
  @@index([ownerId])
}
