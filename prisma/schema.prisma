// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider     = "postgresql"
  url          = env("DATABASE_URL")
  directUrl    = env("DIRECT_URL")
  relationMode = "prisma"
}

model User {
  id                 String    @id @default(cuid())
  email              String    @unique
  name               String
  password           String
  avatarUrl          String?
  workspaceImageUrl  String?   // Imagem específica para a capa do workspace pessoal
  subscriptionStatus String    @default("trial")
  trialExpiresAt     DateTime?
  resetToken         String?   // Token para recuperação de senha
  resetTokenExpiry   DateTime? // Data de expiração do token
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  // Relações
  ownedVaults         Vault[]           @relation("Owner")
  memberships         VaultMember[]
  ownedAccounts       Account[]
  sentInvitations     Invitation[]      @relation("Sender")
  receivedInvitations Invitation[]      @relation("Receiver")
  notifications       Notification[]
  transactionsAsActor Transaction[]     @relation("ActorTransactions")
  transactionsAsOwner Transaction[]     @relation("OwnerTransactions")
  goals               Goal[]
  goalParticipants    GoalParticipant[]
  categories          Category[]

  @@map("users")
}

model Vault {
  id        String   @id @default(cuid())
  name      String
  imageUrl  String?
  ownerId   String
  isPrivate Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relações
  owner   User          @relation("Owner", fields: [ownerId], references: [id], onDelete: Cascade)
  members VaultMember[]
  accounts Account[]
  transactions Transaction[]
  invitations Invitation[]
  goals Goal[]

  @@map("vaults")
}

model VaultMember {
  id      String @id @default(cuid())
  vaultId String
  userId  String
  role    String @default("member")

  // Relações
  vault Vault @relation(fields: [vaultId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime? @updatedAt

  @@unique([vaultId, userId])
  // ⚡ PERFORMANCE: Índices para acesso rápido aos memberships
  @@index([userId], name: "idx_vault_members_user")
  @@index([vaultId], name: "idx_vault_members_vault")
  @@index([userId, vaultId, role], name: "idx_vault_members_user_vault_role")
  @@map("vault_members")
}

model Account {
  id          String   @id @default(cuid())
  name        String
  bank        String
  type        String
  balance     Float
  creditLimit Float?
  logoUrl     String?
  scope       String   // 'personal' ou um vaultId
  visibleIn   String[] @default([]) // Array de vaultIds onde é visível

  // Relações
  ownerId String
  owner   User     @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  vaultId String?
  vault   Vault?   @relation(fields: [vaultId], references: [id], onDelete: Cascade)

  // Transações onde esta conta é a origem ou destino
  transactionsAsSource      Transaction[] @relation("SourceAccount")
  transactionsAsDestination Transaction[] @relation("DestinationAccount")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // ⚡ PERFORMANCE: Índices para consultas de contas
  @@index([ownerId, scope], name: "idx_accounts_owner_scope")
  @@index([vaultId], name: "idx_accounts_vault")
  @@index([ownerId, type], name: "idx_accounts_owner_type")
  @@map("accounts")
}

model Goal {
  id            String   @id @default(cuid())
  name          String
  targetAmount  Float
  currentAmount Float    @default(0)
  emoji         String
  visibility    String   @default("shared") // 'private' ou 'shared'
  isFeatured    Boolean  @default(false)

  // Relações
  userId  String?
  user    User?   @relation(fields: [userId], references: [id], onDelete: Cascade)
  vaultId String?
  vault   Vault?  @relation(fields: [vaultId], references: [id], onDelete: Cascade)

  participants GoalParticipant[]
  transactions Transaction[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // ⚡ PERFORMANCE: Índices para consultas de objetivos
  @@index([userId, createdAt(sort: Desc)], name: "idx_goals_user_created")
  @@index([vaultId, createdAt(sort: Desc)], name: "idx_goals_vault_created")
  @@index([vaultId, isFeatured], name: "idx_goals_vault_featured")
  @@index([userId, visibility], name: "idx_goals_user_visibility")
  @@map("goals")
}

model GoalParticipant {
  // ⚡ PERFORMANCE: Índices para consultas de participação em goals
  @@index([goalId], name: "idx_goal_participants_goal")
  @@index([userId], name: "idx_goal_participants_user")
  id     String @id @default(cuid())
  goalId String
  userId String
  role   String @default("member")

  // Relações
  goal Goal @relation(fields: [goalId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([goalId, userId])
  @@map("goal_participants")
}

model Transaction {
  id              String  @id @default(cuid())
  date            DateTime
  description     String
  amount          Float
  type            String
  paymentMethod   String?
  isRecurring     Boolean @default(false)
  isInstallment   Boolean @default(false)
  installmentNumber Int?
  totalInstallments Int?
  paidInstallments  Int[]    @default([])
  recurringId     String? // Para agrupar transações recorrentes


  // Relações
  actorId             String
  userId              String?
  vaultId             String?
  categoryId          String?
  sourceAccountId     String?
  destinationAccountId String?
  goalId              String?
  
  actor               User      @relation("ActorTransactions", fields: [actorId], references: [id], onDelete: Cascade)
  user                User?     @relation("OwnerTransactions", fields: [userId], references: [id], onDelete: Cascade)
  vault               Vault?    @relation(fields: [vaultId], references: [id], onDelete: Cascade)
  category            Category? @relation(fields: [categoryId], references: [id], onDelete: SetNull)
  sourceAccount       Account?  @relation("SourceAccount", fields: [sourceAccountId], references: [id], onDelete: SetNull)
  destinationAccount  Account?  @relation("DestinationAccount", fields: [destinationAccountId], references: [id], onDelete: SetNull)
  goal                Goal?     @relation(fields: [goalId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // ⚡ PERFORMANCE: Índices críticos para acelerar consultas
  @@index([userId, date(sort: Desc)], name: "idx_transactions_user_date")
  @@index([vaultId, date(sort: Desc)], name: "idx_transactions_vault_date")
  @@index([actorId, date(sort: Desc)], name: "idx_transactions_actor_date")
  @@index([userId, type, date(sort: Desc)], name: "idx_transactions_user_type_date")
  @@index([categoryId, date(sort: Desc)], name: "idx_transactions_category_date")
  @@index([goalId, date(sort: Desc)], name: "idx_transactions_goal_date")
  @@index([recurringId, isRecurring], name: "idx_transactions_recurring")
  @@map("transactions")
}

model Invitation {
  id          String   @id @default(cuid())
  type        String // 'vault' ou 'goal'
  targetId    String
  targetName  String
  senderId    String
  receiverId  String?
  receiverEmail String?
  status      String   @default("pending") // 'pending', 'accepted', 'declined'
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relações
  sender   User  @relation("Sender", fields: [senderId], references: [id], onDelete: Cascade)
  receiver User?  @relation("Receiver", fields: [receiverId], references: [id], onDelete: Cascade)
  vault    Vault? @relation(fields: [targetId], references: [id], onDelete: Cascade)

  // ⚡ PERFORMANCE: Índices para consultas de convites
  @@index([receiverId, status], name: "idx_invitations_receiver_status")
  @@index([receiverEmail, status], name: "idx_invitations_email_status")
  @@index([senderId, createdAt(sort: Desc)], name: "idx_invitations_sender_date")
  @@index([receiverId, type, status], name: "idx_invitations_receiver_type_status")
  @@map("invitations")
}

model Notification {
  id        String   @id @default(cuid())
  userId    String
  type      String
  message   String
  isRead    Boolean  @default(false)
  link      String?
  relatedId String?
  createdAt DateTime @default(now())

  // Relações
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // ⚡ PERFORMANCE: Índices críticos para dashboard
  @@index([userId, isRead, createdAt(sort: Desc)], name: "idx_notifications_user_unread_date")
  @@index([userId, createdAt(sort: Desc)], name: "idx_notifications_user_date")
  @@map("notifications")
}

model SavedReport {
  id                String   @id @default(cuid())
  ownerId           String   // Pode ser um userId ou um vaultId
  monthYear         String
  analysisHtml      String
  transactionCount  Int      @default(0) // Número de transações quando o relatório foi gerado
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@unique([ownerId, monthYear])
  // ⚡ PERFORMANCE: Índice para consultas de relatórios
  @@index([ownerId, monthYear(sort: Desc)], name: "idx_saved_reports_owner_month")
  @@map("saved_reports")
}

model Category {
  id          String   @id @default(cuid())
  name        String
  ownerId     String
  createdAt   DateTime @default(now())
  updatedAt   DateTime? @updatedAt

  owner       User     @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  Transaction Transaction[]

  @@unique([name, ownerId])
  // ⚡ PERFORMANCE: Índice para consultas de categorias ordenadas
  @@index([ownerId, name(sort: Asc)], name: "idx_categories_owner_name")
  @@map("categories")
}
