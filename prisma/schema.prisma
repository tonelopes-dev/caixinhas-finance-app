// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider     = "postgresql"
  url          = env("DATABASE_URL")
  directUrl    = env("DIRECT_URL")
  relationMode = "prisma"
}


// ======================================
//              MODELS
// ======================================

// Modelo de Usuário
model User {
  id                 String    @id @default(cuid())
  email              String    @unique
  name               String
  password           String?
  avatarUrl          String?
  subscriptionStatus String    @default("active") // active, inactive, trial
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  ownedVaults        Vault[]             @relation("OwnedVaults")
  vaultMemberships   VaultMember[]       @relation("VaultMemberships")
  accounts           Account[]
  sentInvitations    Invitation[]        @relation("SentInvitations")
  receivedInvitations Invitation[]       @relation("ReceivedInvitations")
  notifications      Notification[]
  goals              Goal[]
  goalParticipations GoalParticipant[]
  actedTransactions  Transaction[]       @relation("Actor")
  transactions       Transaction[]       @relation("UserTransactions")
  categories         Category[]
  
  // Para NextAuth
  sessions Session[]
  authAccounts Account[] @relation("UserAuthAccounts")
}

// Para NextAuth
model Account {
    id                String  @id @default(cuid())
    userId            String
    type              String
    provider          String
    providerAccountId String
    refresh_token     String? @db.Text
    access_token      String? @db.Text
    expires_at        Int?
    token_type        String?
    scope             String?
    id_token          String? @db.Text
    session_state     String?

    user User @relation("UserAuthAccounts", fields: [userId], references: [id], onDelete: Cascade)

    @@unique([provider, providerAccountId])
}

// Para NextAuth
model Session {
    id           String   @id @default(cuid())
    sessionToken String   @unique
    userId       String
    expires      DateTime
    user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// Para NextAuth
model VerificationToken {
    identifier String
    token      String   @unique
    expires    DateTime

    @@unique([identifier, token])
}


// Modelo de Cofre Compartilhado
model Vault {
  id        String   @id @default(cuid())
  name      String
  imageUrl  String?
  ownerId   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  owner   User          @relation("OwnedVaults", fields: [ownerId], references: [id])
  members VaultMember[]
  accounts Account[]
  goals   Goal[]
  invitations Invitation[]
  transactions Transaction[]
}

// Tabela de Junção para Membros do Cofre
model VaultMember {
  id        String   @id @default(cuid())
  userId    String
  vaultId   String
  role      String   @default("member") // owner, admin, member
  createdAt DateTime @default(now())

  user  User  @relation("VaultMemberships", fields: [userId], references: [id])
  vault Vault @relation(fields: [vaultId], references: [id], onDelete: Cascade)

  @@unique([userId, vaultId])
}

// Modelo de Conta Financeira
model Account {
  id          String  @id @default(cuid())
  name        String
  bank        String
  type        String // checking, savings, investment, credit_card, other
  balance     Float
  creditLimit Float?
  logoUrl     String?
  scope       String // 'personal' ou um vaultId
  ownerId     String
  vaultId     String?
  visibleIn   String[] @default([]) // Array de vaultIds onde é visível

  owner User  @relation(fields: [ownerId], references: [id])
  vault Vault? @relation(fields: [vaultId], references: [id])

  sourceTransactions      Transaction[] @relation("SourceTransactions")
  destinationTransactions Transaction[] @relation("DestinationTransactions")
}

// Modelo de Meta/Caixinha
model Goal {
  id            String   @id @default(cuid())
  name          String
  targetAmount  Float
  currentAmount Float    @default(0)
  emoji         String
  visibility    String   @default("shared") // private, shared
  isFeatured    Boolean  @default(false)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  userId  String?
  vaultId String?

  user         User?             @relation(fields: [userId], references: [id])
  vault        Vault?            @relation(fields: [vaultId], references: [id])
  participants GoalParticipant[]
  transactions Transaction[]
  invitations  Invitation[]
}

// Tabela de Junção para Participantes da Meta
model GoalParticipant {
  id     String @id @default(cuid())
  userId String
  goalId String
  role   String @default("member")

  user User @relation(fields: [userId], references: [id])
  goal Goal @relation(fields: [goalId], references: [id], onDelete: Cascade)

  @@unique([userId, goalId])
}

// Modelo de Transação
model Transaction {
  id                 String   @id @default(cuid())
  date               DateTime
  description        String
  amount             Float
  type               String // income, expense, transfer
  category           String
  paymentMethod      String?
  sourceAccountId    String?
  destinationAccountId String?
  goalId             String?
  actorId            String
  isRecurring        Boolean  @default(false)
  isInstallment      Boolean  @default(false)
  installmentNumber  Int?
  totalInstallments  Int?

  userId             String?
  vaultId            String?

  user          User?    @relation("UserTransactions", fields: [userId], references: [id])
  vault         Vault?   @relation(fields: [vaultId], references: [id])
  sourceAccount      Account? @relation(name: "SourceTransactions", fields: [sourceAccountId], references: [id])
  destinationAccount Account? @relation(name: "DestinationTransactions", fields: [destinationAccountId], references: [id])
  goal          Goal?    @relation(fields: [goalId], references: [id])
  actor         User     @relation(name: "Actor", fields: [actorId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Modelo de Categorias de Despesa personalizadas
model Category {
  id      String @id @default(cuid())
  name    String
  ownerId String
  owner   User   @relation(fields: [ownerId], references: [id])

  @@unique([name, ownerId])
}


// Modelo de Notificação
model Notification {
  id          String   @id @default(cuid())
  userId      String
  type        String
  text        String
  link        String?
  read        Boolean  @default(false)
  actorId     String?
  actorName   String?
  actorAvatar String?
  createdAt   DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// Modelo de Convite
model Invitation {
  id         String   @id @default(cuid())
  type       String // 'vault' ou 'goal'
  targetName String
  senderId   String
  receiverId String
  status     String   @default("pending") // pending, accepted, declined
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  
  vaultId String?
  goalId  String?

  sender   User @relation(name: "SentInvitations", fields: [senderId], references: [id])
  receiver User @relation(name: "ReceivedInvitations", fields: [receiverId], references: [id])

  vault Vault? @relation(fields: [vaultId], references: [id], onDelete: Cascade)
  goal  Goal?  @relation(fields: [goalId], references: [id], onDelete: Cascade)
}


// Modelo para Relatórios Salvos
model SavedReport {
  id           String   @id @default(cuid())
  ownerId      String   // Can be a userId or a vaultId
  monthYear    String   // Format: "YYYY-MM"
  analysisHtml String
  createdAt    DateTime @default(now())

  @@unique([ownerId, monthYear])
}
