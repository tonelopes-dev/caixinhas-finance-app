\"use server\";\n\nimport { VaultService } from \'@/services/vault.service\';\nimport { AuthService } from \'@/services/auth.service\';\nimport { revalidatePath } from \'next/cache\';\nimport { z } from \'zod\';\n\nconst createVaultSchema = z.object({\n  name: z.string().min(1, { message: \'O nome do cofre é obrigatório.\' }),\n  imageUrl: z.string().url().optional(),\n  isPrivate: z.boolean().optional(),\n});\n\nconst updateVaultSchema = z.object({\n  vaultId: z.string().min(1),\n  name: z.string().min(1, { message: \'O nome é obrigatório.\' }),\n  imageUrl: z.string().url().optional(),\n  isPrivate: z.boolean().optional(),\n});\n\nexport type VaultActionState = {\n  message?: string | null;\n  errors?: {\n    name?: string[];\n    imageUrl?: string[];\n  };\n};\n\nexport async function getUserVaultsData(userId: string) {\n  try {\n    const [user, vaults, invitations] = await Promise.all([\n      AuthService.getUserById(userId),\n      VaultService.getUserVaults(userId),\n      VaultService.getPendingInvitations(userId),\n    ]);\n\n    if (!user) return null;\n\n    const formattedVaults = vaults.map((vault) => ({\n      id: vault.id,\n      name: vault.name,\n      imageUrl: vault.imageUrl || \'https://images.unsplash.com/photo-1502672260266-1c1ef2d93688?w=1080\',\n      isPrivate: vault.isPrivate,\n      ownerId: vault.ownerId,\n      members: vault.members.map((member) => ({\n        id: member.user.id,\n        name: member.user.name,\n        email: member.user.email,\n        avatarUrl: member.user.avatarUrl || \'\',\n        subscriptionStatus: \'active\',\n      })),\n    }));\n\n    const formattedInvitations = invitations.map((inv) => ({\n      id: inv.id,\n      vaultId: inv.targetId,\n      vaultName: inv.targetName,\n      invitedBy: inv.sender.name,\n      status: inv.status as \'pending\' | \'accepted\' | \'declined\',\n    }));\n\n    return {\n      currentUser: user,\n      userVaults: formattedVaults,\n      userInvitations: formattedInvitations,\n    };\n  } catch (error) {\n    console.error(\'Erro ao buscar dados dos cofres:\', error);\n    return null;\n  }\n}\n\nexport async function createVaultAction(\n  prevState: VaultActionState,\n  formData: FormData\n): Promise<VaultActionState> {\n  const { requireVaultCreationAccess } = await import(\'@/lib/action-helpers\');\n  const accessCheck = await requireVaultCreationAccess();\n\n  if (!accessCheck.success || !accessCheck.data) {\n    return { message: accessCheck.error || \'Acesso negado\' };\n  }\n  const userId = accessCheck.data.id;\n\n  const validatedFields = createVaultSchema.safeParse({\n    name: formData.get(\'name\'),\n    imageUrl: formData.get(\'imageUrl\') || undefined,\n    isPrivate: formData.get(\'isPrivate\') === \'on\',\n  });\n\n  if (!validatedFields.success) {\n    return { errors: validatedFields.error.flatten().fieldErrors, message: \'Falha na validação.\' };\n  }\n\n  try {\n    const newVault = await VaultService.createVault({ ...validatedFields.data, ownerId: userId });\n    const { cookies } = await import(\'next/headers\');\n    await cookies().set(\'CAIXINHAS_VAULT_ID\', newVault.id, {\n      httpOnly: false,\n      secure: process.env.NODE_ENV === \'production\',\n      sameSite: \'lax\',\n      maxAge: 60 * 60 * 24 * 7,\n      path: \'/\',\n    });\n\n    revalidatePath(\'/vaults\');\n    revalidatePath(\'/dashboard\');\n    return { message: \'Cofre criado com sucesso!\' };\n  } catch (error) {\n    console.error(\'Erro ao criar cofre:\', error);\n    return { message: \'Erro ao criar cofre. Tente novamente.\' };\n  }\n}\n\nexport async function updateVaultAction(\n  prevState: VaultActionState,\n  formData: FormData\n): Promise<VaultActionState> {\n  const { getServerSession } = await import(\'next-auth\');\n  const { authOptions } = await import(\'@/lib/auth\');\n  const session = await getServerSession(authOptions);\n\n  if (!session?.user) return { message: \'Não autorizado\' };\n  const userId = session.user.id;\n\n  const validatedFields = updateVaultSchema.safeParse({\n    vaultId: formData.get(\'vaultId\'),\n    name: formData.get(\'name\'),\n    imageUrl: formData.get(\'imageUrl\') || undefined,\n    isPrivate: formData.get(\'isPrivate\') === \'on\',\n  });\n\n  if (!validatedFields.success) {\n    return { errors: validatedFields.error.flatten().fieldErrors, message: \'Falha na validação.\' };\n  }\n\n  const { vaultId, ...updateData } = validatedFields.data;\n\n  try {\n    const vault = await VaultService.getVaultById(vaultId);\n    if (!vault || vault.ownerId !== userId) {\n      return { message: \'Você não tem permissão para editar este cofre\' };\n    }\n    await VaultService.updateVault(vaultId, updateData);\n\n    revalidatePath(\'/vaults\');\n    revalidatePath(\'/dashboard\');\n    revalidatePath(\'/profile\');\n    \n    return { message: \'Espaço de trabalho atualizado com sucesso!\' };\n  } catch (error) {\n    console.error(\'Erro ao atualizar:\', error);\n    return { message: \'Erro ao atualizar. Tente novamente.\' };\n  }\n}\n\nexport async function acceptInvitationAction(\n  invitationId: string,\n  userId: string\n): Promise<{ success: boolean; message: string }> {\n  try {\n    await VaultService.acceptInvitation(invitationId, userId);\n    revalidatePath(\'/vaults\');\n    return { success: true, message: \'Convite aceito com sucesso!\' };\n  } catch (error) {\n    console.error(\'Erro ao aceitar convite:\', error);\n    return { success: false, message: \'Erro ao aceitar convite. Tente novamente.\' };\n  }\n}\n\nexport async function declineInvitationAction(\n  invitationId: string,\n  userId: string\n): Promise<{ success: boolean; message: string }> {\n  try {\n    await VaultService.declineInvitation(invitationId, userId);\n    revalidatePath(\'/vaults\');\n    return { success: true, message: \'Convite recusado.\' };\n  } catch (error) {\n    console.error(\'Erro ao recusar convite:\', error);\n    return { success: false, message: \'Erro ao recusar convite. Tente novamente.\' };\n  }\n}\n\nexport async function deleteVaultAction(vaultId: string): Promise<{ success: boolean; message: string }> {\n  const { getServerSession } = await import(\'next-auth\');\n  const { authOptions } = await import(\'@/lib/auth\');\n  const session = await getServerSession(authOptions);\n\n  if (!session?.user) return { success: false, message: \'Não autorizado\' };\n  const userId = session.user.id;\n\n  try {\n    const vault = await VaultService.getVaultById(vaultId);\n    if (!vault || vault.ownerId !== userId) {\n      return { success: false, message: \'Você não tem permissão para excluir este cofre\' };\n    }\n    await VaultService.deleteVault(vaultId);\n    revalidatePath(\'/vaults\');\n    revalidatePath(\'/dashboard\');\n    revalidatePath(\'/profile\');\n    return { success: true, message: \'Cofre excluído com sucesso!\' };\n  } catch (error) {\n    console.error(\'Erro ao excluir cofre:\', error);\n    return { success: false, message: \'Erro ao excluir cofre. Tente novamente.\' };\n  }\n}\n\nexport async function removeMemberAction(\n  vaultId: string,\n  memberId: string\n): Promise<{ success: boolean; message: string }> {\n  const { getServerSession } = await import(\'next-auth\');\n  const { authOptions } = await import(\'@/lib/auth\');\n  const session = await getServerSession(authOptions);\n\n  if (!session?.user) return { success: false, message: \'Não autorizado\' };\n  const userId = session.user.id;\n\n  try {\n    const vault = await VaultService.getVaultById(vaultId);\n    if (!vault || vault.ownerId !== userId) {\n      return { success: false, message: \'Você não tem permissão para remover membros deste cofre\' };\n    }\n    await VaultService.removeMember(vaultId, memberId);\n    revalidatePath(\'/vaults\');\n    revalidatePath(\`/vaults/${vaultId}/manage\`);\n    return { success: true, message: \'Membro removido com sucesso!\' };\n  } catch (error) {\n    console.error(\'Erro ao remover membro:\', error);\n    return { success: false, message: \'Erro ao remover membro. Tente novamente.\' };\n  }\n}\n\nexport async function inviteToVaultAction(\n  vaultId: string,\n  email: string\n): Promise<{ success: boolean; message: string }> {\n  const { getServerSession } = await import(\'next-auth\');\n  const { authOptions } = await import(\'@/lib/auth\');\n  const session = await getServerSession(authOptions);\n\n  if (!session?.user) return { success: false, message: \'Não autorizado\' };\n  const userId = session.user.id;\n\n  try {\n    const vault = await VaultService.getVaultById(vaultId);\n    if (!vault || vault.ownerId !== userId) {\n      return { success: false, message: \'Você não tem permissão para convidar para este cofre\' };\n    }\n    await VaultService.inviteToVault(vaultId, email, userId);\n    revalidatePath(\`/vaults/${vaultId}/manage\`);\n    return { success: true, message: \'Convite enviado com sucesso!\' };\n  } catch (error) {\n    console.error(\'Erro ao enviar convite:\', error);\n    return { success: false, message: \'Erro ao enviar convite. Tente novamente.\' };\n  }\n}\n\nexport async function getVaultPendingInvitationsAction(\n  vaultId: string\n): Promise<{ id: string; targetName: string; senderName: string; status: string }[]> {\n  const { getServerSession } = await import(\'next-auth\');\n  const { authOptions } = await import(\'@/lib/auth\');\n  const session = await getServerSession(authOptions);\n\n  if (!session?.user) return [];\n  const userId = session.user.id;\n\n  try {\n    const vault = await VaultService.getVaultById(vaultId);\n    if (!vault || (vault.ownerId !== userId && !vault.members.some(member => member.userId === userId))) {\n      // User must be owner or a member to see pending invitations\n      return [];\n    }\n    const invitations = await VaultService.getVaultPendingInvitations(vaultId);\n    return invitations.map(inv => ({\n      id: inv.id,\n      targetName: inv.targetName,\n      senderName: inv.sender.name,\n      status: inv.status,\n    }));\n  } catch (error) {\n    console.error(\'Erro ao buscar convites pendentes do cofre:\', error);\n    return [];\n  }\n}\n\nexport async function cancelInvitationAction(\n  invitationId: string,\n  vaultId: string\n): Promise<{ success: boolean; message: string }> {\n  const { getServerSession } = await import(\'next-auth\');\n  const { authOptions } = await import(\'@/lib/auth\');\n  const session = await getServerSession(authOptions);\n\n  if (!session?.user) return { success: false, message: \'Não autorizado\' };\n  const userId = session.user.id;\n\n  try {\n    const invitation = await VaultService.getInvitationById(invitationId);\n    if (!invitation || invitation.senderId !== userId) {\n      return { success: false, message: \'Você não tem permissão para cancelar este convite\' };\n    }\n    await VaultService.cancelInvitation(invitationId);\n    revalidatePath(\`/vaults/${vaultId}/manage\`);\n    return { success: true, message: \'Convite cancelado com sucesso!\' };\n  } catch (error) {\n    console.error(\'Erro ao cancelar convite:\', error);\n    return { success: false, message: \'Erro ao cancelar convite. Tente novamente.\' };\n  }\n}\n